--- ../38/Include/picklebufobject.h	2020-05-10 16:01:50.000000000 -0700
+++ pickle5/picklebufobject.h	2019-10-10 21:27:34.000000000 -0700
@@ -10,18 +10,18 @@
 
 #ifndef Py_LIMITED_API
 
-PyAPI_DATA(PyTypeObject) PyPickleBuffer_Type;
+extern PyTypeObject PyPickleBuffer_Type;
 
 #define PyPickleBuffer_Check(op) (Py_TYPE(op) == &PyPickleBuffer_Type)
 
 /* Create a PickleBuffer redirecting to the given buffer-enabled object */
-PyAPI_FUNC(PyObject *) PyPickleBuffer_FromObject(PyObject *);
+PyObject *PyPickleBuffer_FromObject(PyObject *);
 /* Get the PickleBuffer's underlying view to the original object
  * (NULL if released)
  */
-PyAPI_FUNC(const Py_buffer *) PyPickleBuffer_GetBuffer(PyObject *);
+const Py_buffer *PyPickleBuffer_GetBuffer(PyObject *);
 /* Release the PickleBuffer.  Returns 0 on success, -1 on error. */
-PyAPI_FUNC(int) PyPickleBuffer_Release(PyObject *);
+int PyPickleBuffer_Release(PyObject *);
 
 #endif /* !Py_LIMITED_API */
 
--- ../38/Objects/picklebufobject.c	2020-05-10 16:01:50.000000000 -0700
+++ pickle5/picklebufobject.c	2019-10-10 21:29:15.000000000 -0700
@@ -4,6 +4,8 @@
 #include "Python.h"
 #include <stddef.h>
 
+#include "picklebufobject.h"
+
 typedef struct {
     PyObject_HEAD
     /* The view exported by the original object */
--- ../38/Modules/_pickle.c	2020-05-10 16:01:50.000000000 -0700
+++ pickle5/_pickle.c	2020-02-14 17:54:56.000000000 -0800
@@ -1,11 +1,11 @@
-/* pickle accelerator C extensor: _pickle module.
- *
- * It is built as a built-in module (Py_BUILD_CORE_BUILTIN define) on Windows
- * and as an extension module (Py_BUILD_CORE_MODULE define) on other
- * platforms. */
 
-#if !defined(Py_BUILD_CORE_BUILTIN) && !defined(Py_BUILD_CORE_MODULE)
-#  error "Py_BUILD_CORE_BUILTIN or Py_BUILD_CORE_MODULE must be defined"
+#include "compat.h"
+#include "picklebufobject.h"
+
+/* Core extension modules are built-in on some platforms (e.g. Windows). */
+#ifdef Py_BUILD_CORE
+#define Py_BUILD_CORE_BUILTIN
+#undef Py_BUILD_CORE
 #endif
 
 #include "Python.h"
@@ -709,7 +709,16 @@
 static PyTypeObject Pickler_Type;
 static PyTypeObject Unpickler_Type;
 
+
+#if PY_VERSION_HEX < 0x03060000
+#include "clinic/_pickle-3.5.c.h"
+#elif PY_VERSION_HEX < 0x03070000
+#include "clinic/_pickle-3.6.c.h"
+#elif PY_VERSION_HEX < 0x03080000
+#include "clinic/_pickle-3.7.c.h"
+#else
 #include "clinic/_pickle.c.h"
+#endif
 
 /*************************************************************************
  A custom hashtable mapping void* to Python ints. This is used by the pickler
@@ -4457,12 +4466,13 @@
 dump(PicklerObject *self, PyObject *obj)
 {
     const char stop_op = STOP;
+    int status = -1;
     PyObject *tmp;
     _Py_IDENTIFIER(reducer_override);
 
     if (_PyObject_LookupAttrId((PyObject *)self, &PyId_reducer_override,
                                &tmp) < 0) {
-        return -1;
+        goto error;
     }
     /* Cache the reducer_override method, if it exists. */
     if (tmp != NULL) {
@@ -4479,7 +4489,7 @@
         assert(self->proto >= 0 && self->proto < 256);
         header[1] = (unsigned char)self->proto;
         if (_Pickler_Write(self, header, 2) < 0)
-            return -1;
+            goto error;
         if (self->proto >= 4)
             self->framing = 1;
     }
@@ -4487,9 +4497,22 @@
     if (save(self, obj, 0) < 0 ||
         _Pickler_Write(self, &stop_op, 1) < 0 ||
         _Pickler_CommitFrame(self) < 0)
-        return -1;
+        goto error;
+
+    // Success
+    status = 0;
+
+  error:
     self->framing = 0;
-    return 0;
+
+    /* Break the reference cycle we generated at the beginning this function
+     * call when setting the reducer_override attribute of the Pickler instance
+     * to a bound method of the same instance. This is important as the Pickler
+     * instance holds a reference to each object it has pickled (through its
+     * memo): thus, these objects wont be garbage-collected as long as the
+     * Pickler itself is not collected. */
+    Py_CLEAR(self->reducer_override);
+    return status;
 }
 
 /*[clinic input]
@@ -7020,11 +7043,6 @@
     PyObject *global;
     PyObject *module;
 
-    if (PySys_Audit("pickle.find_class", "OO",
-                    module_name, global_name) < 0) {
-        return NULL;
-    }
-
     /* Try to map the old names used in Python 2.x to the new ones used in
        Python 3.x.  We do this only with old pickle protocols and when the
        user has not disabled the feature. */
@@ -7877,11 +7895,25 @@
     return NULL;
 }
 
+static PyObject*
+make_memoryview_readonly(PyObject *self, PyObject *arg)
+{
+    if (!PyMemoryView_Check(arg)) {
+        PyErr_Format(PyExc_TypeError,
+                     "_make_memoryview_readonly() argument must be memoryview");
+        return NULL;
+    }
+    PyMemoryViewObject *mv = (PyMemoryViewObject *) arg;
+    mv->view.readonly = 1;
+    Py_RETURN_NONE;
+}
+
 static struct PyMethodDef pickle_methods[] = {
     _PICKLE_DUMP_METHODDEF
     _PICKLE_DUMPS_METHODDEF
     _PICKLE_LOAD_METHODDEF
     _PICKLE_LOADS_METHODDEF
+    {"_make_memoryview_readonly", make_memoryview_readonly, METH_O},
     {NULL, NULL} /* sentinel */
 };
 
@@ -7965,6 +7997,8 @@
     Py_INCREF(&Unpickler_Type);
     if (PyModule_AddObject(m, "Unpickler", (PyObject *)&Unpickler_Type) < 0)
         return NULL;
+    if (PyType_Ready(&PyPickleBuffer_Type) < 0)
+        return NULL;
     Py_INCREF(&PyPickleBuffer_Type);
     if (PyModule_AddObject(m, "PickleBuffer",
                            (PyObject *)&PyPickleBuffer_Type) < 0)
--- ../38/Lib/pickle.py	2020-05-10 16:01:50.000000000 -0700
+++ pickle5/pickle.py	2019-12-07 22:59:41.000000000 -0800
@@ -40,7 +40,7 @@
            "Unpickler", "dump", "dumps", "load", "loads"]
 
 try:
-    from _pickle import PickleBuffer
+    from ._pickle import PickleBuffer, _make_memoryview_readonly
     __all__.append("PickleBuffer")
     _HAVE_PICKLE_BUFFER = True
 except ImportError:
@@ -1405,7 +1405,9 @@
         buf = self.stack[-1]
         with memoryview(buf) as m:
             if not m.readonly:
-                self.stack[-1] = m.toreadonly()
+                mm = memoryview(buf)
+                _make_memoryview_readonly(mm)
+                self.stack[-1] = mm
     dispatch[READONLY_BUFFER[0]] = load_readonly_buffer
 
     def load_short_binstring(self):
@@ -1568,7 +1570,6 @@
 
     def find_class(self, module, name):
         # Subclasses may override this.
-        sys.audit('pickle.find_class', module, name)
         if self.proto < 3 and self.fix_imports:
             if (module, name) in _compat_pickle.NAME_MAPPING:
                 module, name = _compat_pickle.NAME_MAPPING[(module, name)]
@@ -1759,7 +1760,7 @@
 
 # Use the faster _pickle if possible
 try:
-    from _pickle import (
+    from ._pickle import (
         PickleError,
         PicklingError,
         UnpicklingError,
--- ../38/Lib/pickletools.py	2020-05-10 16:01:50.000000000 -0700
+++ pickle5/pickletools.py	2019-10-10 22:43:59.000000000 -0700
@@ -12,10 +12,11 @@
 
 import codecs
 import io
-import pickle
 import re
 import sys
 
+from . import pickle
+
 __all__ = ['dis', 'genops', 'optimize']
 
 bytes_types = pickle.bytes_types
--- ../38/Lib/test/pickletester.py	2020-05-10 16:01:50.000000000 -0700
+++ pickle5/test/pickletester.py	2020-05-17 01:26:59.000000000 -0700
@@ -5,8 +5,6 @@
 import functools
 import os
 import math
-import pickle
-import pickletools
 import shutil
 import struct
 import sys
@@ -23,6 +21,38 @@
 
 try:
     import numpy as np
+
+    def _numpy_ndarray_reduce(array):
+        # This function is implemented according to 'array_reduce_ex_picklebuffer'
+        # in numpy C backend. This is a workaround for python3.5 pickling support.
+        if ((not array.flags.c_contiguous and not array.flags.f_contiguous) or
+                (issubclass(type(array), np.ndarray) and type(array) is not np.ndarray) or
+                array.dtype == "O" or array.itemsize == 0):
+            return array.__reduce__()
+
+        # This function is implemented according to 'array_reduce_ex_picklebuffer'
+        # in numpy C backend. This is a workaround for python3.5 pickling support.
+        from pickle5 import PickleBuffer as picklebuf_class
+
+        # if the array if Fortran-contiguous and not C-contiguous,
+        # the PickleBuffer instance will hold a view on the transpose
+        # of the initial array, that is C-contiguous.
+        if not array.flags.c_contiguous and array.flags.f_contiguous:
+            order = "F"
+            picklebuf_args = array.transpose()
+        else:
+            order = "C"
+            picklebuf_args = array
+        try:
+            buffer = picklebuf_class(picklebuf_args)
+        except Exception:
+            # Some arrays may refuse to export a buffer, in which case
+            # just fall back on regular __reduce_ex__ implementation
+            # (gh-12745).
+            return array.__reduce__()
+        from numpy.core.numeric import _frombuffer
+        return _frombuffer, (buffer, array.dtype, array.shape, order)
+
 except ImportError:
     np = None
 
@@ -32,7 +62,8 @@
     _2G, _4G, bigmemtest, reap_threads, forget,
     )
 
-from pickle import bytes_types
+import pickle5 as pickle
+from pickle5 import pickletools, bytes_types
 
 requires_32b = unittest.skipUnless(sys.maxsize < 2**32,
                                    "test is only meaningful on 32-bit builds")
@@ -273,9 +304,9 @@
             return not (self == other)
 
         def __repr__(self):
-            return (f"{type(self)}(shape={self.array.shape},"
-                    f"strides={self.array.strides}, "
-                    f"bytes={self.array.tobytes()})")
+            return ("{}(shape={}, strides={}, bytes={})".format(
+                type(self), self.array.shape, self.array.strides,
+                self.array.tobytes()))
 
         def __reduce_ex__(self, protocol):
             if not self.array.contiguous:
@@ -1445,12 +1476,11 @@
     # of 1.
     def dont_test_disassembly(self):
         from io import StringIO
-        from pickletools import dis
 
         for proto, expected in (0, DATA0_DIS), (1, DATA1_DIS):
             s = self.dumps(self._testdata, proto)
             filelike = StringIO()
-            dis(s, out=filelike)
+            pickletools.dis(s, out=filelike)
             got = filelike.getvalue()
             self.assertEqual(expected, got)
 
@@ -2095,6 +2125,10 @@
         x = ComplexNewObjEx.__new__(ComplexNewObjEx, 0xface)  # avoid __init__
         x.abc = 666
         for proto in protocols:
+            if sys.version_info < (3, 6) and proto < 4:
+                # '__getnewargs_ex__' is not supported in protocol 2 & 3 before Python3.6.
+                # See https://docs.python.org/3/library/pickle.html#object.__getnewargs_ex__
+                continue
             with self.subTest(proto=proto):
                 s = self.dumps(x, proto)
                 if proto < 1:
@@ -2328,7 +2362,6 @@
         elif frameless_start is not None:
             self.assertLess(pos - frameless_start, self.FRAME_SIZE_MIN)
 
-    @support.skip_if_pgo_task
     def test_framing_many_objects(self):
         obj = list(range(10**5))
         for proto in range(4, pickle.HIGHEST_PROTOCOL + 1):
@@ -2418,7 +2451,6 @@
                                 count_opcode(pickle.FRAME, pickled))
                 self.assertEqual(obj, self.loads(some_frames_pickle))
 
-    @support.skip_if_pgo_task
     def test_framed_write_sizes_with_delayed_writer(self):
         class ChunkAccumulator:
             """Accumulate pickler output in a list of raw chunks."""
@@ -2774,6 +2806,12 @@
 
     @unittest.skipIf(np is None, "Test needs Numpy")
     def test_buffers_numpy(self):
+        def _reduce(items):
+            base_obj = items[0](*items[1])
+            if len(items) > 2:
+                base_obj.__setstate__(items[2])
+            return base_obj
+
         def check_no_copy(x, y):
             np.testing.assert_equal(x, y)
             self.assertEqual(x.ctypes.data, y.ctypes.data)
@@ -2785,20 +2823,32 @@
         def check_array(arr):
             # In-band
             for proto in range(0, pickle.HIGHEST_PROTOCOL + 1):
-                data = self.dumps(arr, proto)
-                new = self.loads(data)
+                if sys.version_info < (3, 6) and proto >= 5:
+                    data = self.dumps(_numpy_ndarray_reduce(arr), proto)
+                    new = _reduce(self.loads(data))
+                else:
+                    data = self.dumps(arr, proto)
+                    new = self.loads(data)
                 check_copy(arr, new)
             for proto in range(5, pickle.HIGHEST_PROTOCOL + 1):
                 buffer_callback = lambda _: True
-                data = self.dumps(arr, proto, buffer_callback=buffer_callback)
-                new = self.loads(data)
+                if sys.version_info < (3, 6):
+                    data = self.dumps(_numpy_ndarray_reduce(arr), proto, buffer_callback=buffer_callback)
+                    new = _reduce(self.loads(data))
+                else:
+                    data = self.dumps(arr, proto, buffer_callback=buffer_callback)
+                    new = self.loads(data)
                 check_copy(arr, new)
             # Out-of-band
             for proto in range(5, pickle.HIGHEST_PROTOCOL + 1):
                 buffers = []
                 buffer_callback = buffers.append
-                data = self.dumps(arr, proto, buffer_callback=buffer_callback)
-                new = self.loads(data, buffers=buffers)
+                if sys.version_info < (3, 6):
+                    data = self.dumps(_numpy_ndarray_reduce(arr), proto, buffer_callback=buffer_callback)
+                    new = _reduce(self.loads(data, buffers=buffers))
+                else:
+                    data = self.dumps(arr, proto, buffer_callback=buffer_callback)
+                    new = self.loads(data, buffers=buffers)
                 if arr.flags.c_contiguous or arr.flags.f_contiguous:
                     check_no_copy(arr, new)
                 else:
@@ -3497,6 +3547,30 @@
                         ValueError, 'The reducer just failed'):
                     p.dump(h)
 
+    @support.cpython_only
+    def test_reducer_override_no_reference_cycle(self):
+        # bpo-39492: reducer_override used to induce a spurious reference cycle
+        # inside the Pickler object, that could prevent all serialized objects
+        # from being garbage-collected without explicity invoking gc.collect.
+
+        for proto in range(0, pickle.HIGHEST_PROTOCOL + 1):
+            with self.subTest(proto=proto):
+                def f():
+                    pass
+
+                wr = weakref.ref(f)
+
+                bio = io.BytesIO()
+                p = self.pickler_class(bio, proto)
+                p.dump(f)
+                new_f = pickle.loads(bio.getvalue())
+                assert new_f == 5
+
+                del p
+                del f
+
+                self.assertIsNone(wr())
+
 
 class AbstractDispatchTableTests(unittest.TestCase):
 
--- ../38/Lib/test/test_pickle.py	2020-05-10 16:01:50.000000000 -0700
+++ pickle5/test/test_pickle.py	2020-05-16 22:15:47.000000000 -0700
@@ -1,7 +1,6 @@
 from _compat_pickle import (IMPORT_MAPPING, REVERSE_IMPORT_MAPPING,
                             NAME_MAPPING, REVERSE_NAME_MAPPING)
 import builtins
-import pickle
 import io
 import collections
 import struct
@@ -11,19 +10,20 @@
 import unittest
 from test import support
 
-from test.pickletester import AbstractHookTests
-from test.pickletester import AbstractUnpickleTests
-from test.pickletester import AbstractPickleTests
-from test.pickletester import AbstractPickleModuleTests
-from test.pickletester import AbstractPersistentPicklerTests
-from test.pickletester import AbstractIdentityPersistentPicklerTests
-from test.pickletester import AbstractPicklerUnpicklerObjectTests
-from test.pickletester import AbstractDispatchTableTests
-from test.pickletester import AbstractCustomPicklerClass
-from test.pickletester import BigmemPickleTests
+from .pickletester import AbstractHookTests
+from .pickletester import AbstractUnpickleTests
+from .pickletester import AbstractPickleTests
+from .pickletester import AbstractPickleModuleTests
+from .pickletester import AbstractPersistentPicklerTests
+from .pickletester import AbstractIdentityPersistentPicklerTests
+from .pickletester import AbstractPicklerUnpicklerObjectTests
+from .pickletester import AbstractDispatchTableTests
+from .pickletester import AbstractCustomPicklerClass
+from .pickletester import BigmemPickleTests
 
+import pickle5 as pickle
 try:
-    import _pickle
+    from pickle5 import _pickle
     has_c_implementation = True
 except ImportError:
     has_c_implementation = False
@@ -212,7 +212,7 @@
 
 if has_c_implementation:
     class CPickleTests(AbstractPickleModuleTests):
-        from _pickle import dump, dumps, load, loads, Pickler, Unpickler
+        from pickle5._pickle import dump, dumps, load, loads, Pickler, Unpickler
 
     class CUnpicklerTests(PyUnpicklerTests):
         unpickler = _pickle.Unpickler
--- ../38/Lib/test/test_picklebuffer.py	2020-05-10 16:01:50.000000000 -0700
+++ pickle5/test/test_picklebuffer.py	2019-12-07 22:59:41.000000000 -0800
@@ -4,12 +4,13 @@
 """
 
 import gc
-from pickle import PickleBuffer
 import weakref
 import unittest
 
 from test import support
 
+from pickle5 import PickleBuffer
+
 
 class B(bytes):
     pass
