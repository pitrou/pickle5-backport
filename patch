--- ../cpython-3.8.0rc1/Include/picklebufobject.h	2019-10-01 05:58:26.000000000 -0700
+++ pickle5/picklebufobject.h	2019-10-10 21:27:34.000000000 -0700
@@ -10,18 +10,18 @@
 
 #ifndef Py_LIMITED_API
 
-PyAPI_DATA(PyTypeObject) PyPickleBuffer_Type;
+extern PyTypeObject PyPickleBuffer_Type;
 
 #define PyPickleBuffer_Check(op) (Py_TYPE(op) == &PyPickleBuffer_Type)
 
 /* Create a PickleBuffer redirecting to the given buffer-enabled object */
-PyAPI_FUNC(PyObject *) PyPickleBuffer_FromObject(PyObject *);
+PyObject *PyPickleBuffer_FromObject(PyObject *);
 /* Get the PickleBuffer's underlying view to the original object
  * (NULL if released)
  */
-PyAPI_FUNC(const Py_buffer *) PyPickleBuffer_GetBuffer(PyObject *);
+const Py_buffer *PyPickleBuffer_GetBuffer(PyObject *);
 /* Release the PickleBuffer.  Returns 0 on success, -1 on error. */
-PyAPI_FUNC(int) PyPickleBuffer_Release(PyObject *);
+int PyPickleBuffer_Release(PyObject *);
 
 #endif /* !Py_LIMITED_API */
 
--- ../cpython-3.8.0rc1/Objects/picklebufobject.c	2019-10-01 05:58:26.000000000 -0700
+++ pickle5/picklebufobject.c	2019-10-10 21:29:15.000000000 -0700
@@ -4,6 +4,8 @@
 #include "Python.h"
 #include <stddef.h>
 
+#include "picklebufobject.h"
+
 typedef struct {
     PyObject_HEAD
     /* The view exported by the original object */
--- ../cpython-3.8.0rc1/Modules/_pickle.c	2019-10-01 05:58:26.000000000 -0700
+++ pickle5/_pickle.c	2019-10-11 00:33:54.000000000 -0700
@@ -1,11 +1,11 @@
-/* pickle accelerator C extensor: _pickle module.
- *
- * It is built as a built-in module (Py_BUILD_CORE_BUILTIN define) on Windows
- * and as an extension module (Py_BUILD_CORE_MODULE define) on other
- * platforms. */
 
-#if !defined(Py_BUILD_CORE_BUILTIN) && !defined(Py_BUILD_CORE_MODULE)
-#  error "Py_BUILD_CORE_BUILTIN or Py_BUILD_CORE_MODULE must be defined"
+#include "compat.h"
+#include "picklebufobject.h"
+
+/* Core extension modules are built-in on some platforms (e.g. Windows). */
+#ifdef Py_BUILD_CORE
+#define Py_BUILD_CORE_BUILTIN
+#undef Py_BUILD_CORE
 #endif
 
 #include "Python.h"
@@ -709,7 +709,13 @@
 static PyTypeObject Pickler_Type;
 static PyTypeObject Unpickler_Type;
 
+#if PY_VERSION_HEX < 0x03070000
+#include "clinic/_pickle-3.6.c.h"
+#elif PY_VERSION_HEX < 0x03080000
+#include "clinic/_pickle-3.7.c.h"
+#else
 #include "clinic/_pickle.c.h"
+#endif
 
 /*************************************************************************
  A custom hashtable mapping void* to Python ints. This is used by the pickler
@@ -1141,8 +1147,7 @@
 _Pickler_SetProtocol(PicklerObject *self, PyObject *protocol, int fix_imports)
 {
     long proto;
-
-    if (protocol == Py_None) {
+    if (protocol == NULL || protocol == Py_None) {
         proto = DEFAULT_PROTOCOL;
     }
     else {
@@ -1356,6 +1361,8 @@
 {
     assert(n != READ_WHOLE_LINE);
 
+    /* XXX add tests from ogrisel's use case */
+
     /* Read from available buffer data, if any */
     Py_ssize_t in_buffer = self->input_len - self->next_read_idx;
     if (in_buffer > 0) {
@@ -1371,11 +1378,22 @@
     }
 
     /* Read from file */
-    if (!self->readinto) {
-        return bad_readline();
-    }
-    if (_Unpickler_SkipConsumed(self) < 0) {
+    if (_Unpickler_SkipConsumed(self) < 0)
         return -1;
+
+    Py_ssize_t read_size;
+
+    if (self->readinto == NULL) {
+        /* Call read() and memcpy */
+        /* XXX do we want this fallback? pickle.py doesn't have it */
+        char *s;
+        read_size = _Unpickler_ReadImpl(self, &s, n);
+        if (read_size < 0) {
+            return -1;
+        }
+        assert(read_size == n);
+        memcpy(buf, s, n);
+        return n;
     }
 
     /* Call readinto() into user buffer */
@@ -1387,7 +1405,7 @@
     if (read_size_obj == NULL) {
         return -1;
     }
-    Py_ssize_t read_size = PyLong_AsSsize_t(read_size_obj);
+    read_size = PyLong_AsSsize_t(read_size_obj);
     Py_DECREF(read_size_obj);
 
     if (read_size < 0) {
@@ -1606,17 +1624,19 @@
     _Py_IDENTIFIER(readinto);
     _Py_IDENTIFIER(readline);
 
+    /* Both 'peek' and 'readline' are optional, for compatibility */
     if (_PyObject_LookupAttrId(file, &PyId_peek, &self->peek) < 0) {
         return -1;
     }
+    if (_PyObject_LookupAttrId(file, &PyId_readinto, &self->readinto) < 0) {
+        return -1;
+    }
     (void)_PyObject_LookupAttrId(file, &PyId_read, &self->read);
-    (void)_PyObject_LookupAttrId(file, &PyId_readinto, &self->readinto);
     (void)_PyObject_LookupAttrId(file, &PyId_readline, &self->readline);
-    if (!self->readline || !self->readinto || !self->read) {
+    if (self->readline == NULL || self->read == NULL) {
         if (!PyErr_Occurred()) {
             PyErr_SetString(PyExc_TypeError,
-                            "file must have 'read', 'readinto' and "
-                            "'readline' attributes");
+                            "file must have 'read' and 'readline' attributes");
         }
         Py_CLEAR(self->read);
         Py_CLEAR(self->readinto);
@@ -4870,10 +4890,10 @@
     sizeof(PicklerMemoProxyObject),             /*tp_basicsize*/
     0,
     (destructor)PicklerMemoProxy_dealloc,       /* tp_dealloc */
-    0,                                          /* tp_vectorcall_offset */
+    0,                                          /* tp_print */
     0,                                          /* tp_getattr */
     0,                                          /* tp_setattr */
-    0,                                          /* tp_as_async */
+    0,                                          /* tp_compare */
     0,                                          /* tp_repr */
     0,                                          /* tp_as_number */
     0,                                          /* tp_as_sequence */
@@ -5031,10 +5051,10 @@
     sizeof(PicklerObject),              /*tp_basicsize*/
     0,                                  /*tp_itemsize*/
     (destructor)Pickler_dealloc,        /*tp_dealloc*/
-    0,                                  /*tp_vectorcall_offset*/
+    0,                                  /*tp_print*/
     0,                                  /*tp_getattr*/
     0,                                  /*tp_setattr*/
-    0,                                  /*tp_as_async*/
+    0,                                  /*tp_reserved*/
     0,                                  /*tp_repr*/
     0,                                  /*tp_as_number*/
     0,                                  /*tp_as_sequence*/
@@ -7020,11 +7040,6 @@
     PyObject *global;
     PyObject *module;
 
-    if (PySys_Audit("pickle.find_class", "OO",
-                    module_name, global_name) < 0) {
-        return NULL;
-    }
-
     /* Try to map the old names used in Python 2.x to the new ones used in
        Python 3.x.  We do this only with old pickle protocols and when the
        user has not disabled the feature. */
@@ -7408,10 +7423,10 @@
     sizeof(UnpicklerMemoProxyObject),           /*tp_basicsize*/
     0,
     (destructor)UnpicklerMemoProxy_dealloc,     /* tp_dealloc */
-    0,                                          /* tp_vectorcall_offset */
+    0,                                          /* tp_print */
     0,                                          /* tp_getattr */
     0,                                          /* tp_setattr */
-    0,                                          /* tp_as_async */
+    0,                                          /* tp_compare */
     0,                                          /* tp_repr */
     0,                                          /* tp_as_number */
     0,                                          /* tp_as_sequence */
@@ -7579,10 +7594,10 @@
     sizeof(UnpicklerObject),            /*tp_basicsize*/
     0,                                  /*tp_itemsize*/
     (destructor)Unpickler_dealloc,      /*tp_dealloc*/
-    0,                                  /*tp_vectorcall_offset*/
+    0,                                  /*tp_print*/
     0,                                  /*tp_getattr*/
     0,                                  /*tp_setattr*/
-    0,                                  /*tp_as_async*/
+    0,                                  /*tp_reserved*/
     0,                                  /*tp_repr*/
     0,                                  /*tp_as_number*/
     0,                                  /*tp_as_sequence*/
@@ -7790,7 +7805,7 @@
 _pickle_load_impl(PyObject *module, PyObject *file, int fix_imports,
                   const char *encoding, const char *errors,
                   PyObject *buffers)
-/*[clinic end generated code: output=250452d141c23e76 input=46c7c31c92f4f371]*/
+/*[clinic end generated code: output=250452d141c23e76 input=29fae982fe778156]*/
 {
     PyObject *result;
     UnpicklerObject *unpickler = _Unpickler_New();
@@ -7877,11 +7892,25 @@
     return NULL;
 }
 
+static PyObject*
+make_memoryview_readonly(PyObject *self, PyObject *arg)
+{
+    if (!PyMemoryView_Check(arg)) {
+        PyErr_Format(PyExc_TypeError,
+                     "_make_memoryview_readonly() argument must be memoryview");
+        return NULL;
+    }
+    PyMemoryViewObject *mv = (PyMemoryViewObject *) arg;
+    mv->view.readonly = 1;
+    Py_RETURN_NONE;
+}
+
 static struct PyMethodDef pickle_methods[] = {
     _PICKLE_DUMP_METHODDEF
     _PICKLE_DUMPS_METHODDEF
     _PICKLE_LOAD_METHODDEF
     _PICKLE_LOADS_METHODDEF
+    {"_make_memoryview_readonly", make_memoryview_readonly, METH_O},
     {NULL, NULL} /* sentinel */
 };
 
@@ -7965,6 +7994,8 @@
     Py_INCREF(&Unpickler_Type);
     if (PyModule_AddObject(m, "Unpickler", (PyObject *)&Unpickler_Type) < 0)
         return NULL;
+    if (PyType_Ready(&PyPickleBuffer_Type) < 0)
+        return NULL;
     Py_INCREF(&PyPickleBuffer_Type);
     if (PyModule_AddObject(m, "PickleBuffer",
                            (PyObject *)&PyPickleBuffer_Type) < 0)
--- ../cpython-3.8.0rc1/Lib/pickle.py	2019-10-10 22:44:17.000000000 -0700
+++ pickle5/pickle.py	2019-10-10 22:53:55.000000000 -0700
@@ -36,11 +36,13 @@
 import codecs
 import _compat_pickle
 
+from ._pickle import _make_memoryview_readonly
+
 __all__ = ["PickleError", "PicklingError", "UnpicklingError", "Pickler",
            "Unpickler", "dump", "dumps", "load", "loads"]
 
 try:
-    from _pickle import PickleBuffer
+    from ._pickle import PickleBuffer
     __all__.append("PickleBuffer")
     _HAVE_PICKLE_BUFFER = True
 except ImportError:
@@ -566,7 +568,11 @@
             else:
                 # Check for a class with a custom metaclass; treat as regular
                 # class
-                if issubclass(t, type):
+                try:
+                    issc = issubclass(t, type)
+                except TypeError: # t is not a class (old Boost; see SF #502085)
+                    issc = False
+                if issc:
                     self.save_global(obj)
                     return
 
@@ -1405,7 +1411,9 @@
         buf = self.stack[-1]
         with memoryview(buf) as m:
             if not m.readonly:
-                self.stack[-1] = m.toreadonly()
+                mm = memoryview(buf)
+                _make_memoryview_readonly(mm)
+                self.stack[-1] = mm
     dispatch[READONLY_BUFFER[0]] = load_readonly_buffer
 
     def load_short_binstring(self):
@@ -1568,7 +1576,6 @@
 
     def find_class(self, module, name):
         # Subclasses may override this.
-        sys.audit('pickle.find_class', module, name)
         if self.proto < 3 and self.fix_imports:
             if (module, name) in _compat_pickle.NAME_MAPPING:
                 module, name = _compat_pickle.NAME_MAPPING[(module, name)]
@@ -1759,7 +1766,7 @@
 
 # Use the faster _pickle if possible
 try:
-    from _pickle import (
+    from ._pickle import (
         PickleError,
         PicklingError,
         UnpicklingError,
--- ../cpython-3.8.0rc1/Lib/pickletools.py	2019-10-01 05:58:26.000000000 -0700
+++ pickle5/pickletools.py	2019-10-10 22:43:59.000000000 -0700
@@ -12,10 +12,11 @@
 
 import codecs
 import io
-import pickle
 import re
 import sys
 
+from . import pickle
+
 __all__ = ['dis', 'genops', 'optimize']
 
 bytes_types = pickle.bytes_types
--- ../cpython-3.8.0rc1/Lib/test/pickletester.py	2019-10-01 05:58:26.000000000 -0700
+++ pickle5/test/pickletester.py	2019-10-10 23:13:54.000000000 -0700
@@ -5,8 +5,6 @@
 import functools
 import os
 import math
-import pickle
-import pickletools
 import shutil
 import struct
 import sys
@@ -32,7 +30,8 @@
     _2G, _4G, bigmemtest, reap_threads, forget,
     )
 
-from pickle import bytes_types
+import pickle5 as pickle
+from pickle5 import pickletools, bytes_types
 
 requires_32b = unittest.skipUnless(sys.maxsize < 2**32,
                                    "test is only meaningful on 32-bit builds")
@@ -1445,12 +1444,11 @@
     # of 1.
     def dont_test_disassembly(self):
         from io import StringIO
-        from pickletools import dis
 
         for proto, expected in (0, DATA0_DIS), (1, DATA1_DIS):
             s = self.dumps(self._testdata, proto)
             filelike = StringIO()
-            dis(s, out=filelike)
+            pickletools.dis(s, out=filelike)
             got = filelike.getvalue()
             self.assertEqual(expected, got)
 
@@ -2328,7 +2326,6 @@
         elif frameless_start is not None:
             self.assertLess(pos - frameless_start, self.FRAME_SIZE_MIN)
 
-    @support.skip_if_pgo_task
     def test_framing_many_objects(self):
         obj = list(range(10**5))
         for proto in range(4, pickle.HIGHEST_PROTOCOL + 1):
@@ -2418,7 +2415,6 @@
                                 count_opcode(pickle.FRAME, pickled))
                 self.assertEqual(obj, self.loads(some_frames_pickle))
 
-    @support.skip_if_pgo_task
     def test_framed_write_sizes_with_delayed_writer(self):
         class ChunkAccumulator:
             """Accumulate pickler output in a list of raw chunks."""
--- ../cpython-3.8.0rc1/Lib/test/test_pickle.py	2019-10-01 05:58:26.000000000 -0700
+++ pickle5/test/test_pickle.py	2019-10-11 00:36:01.000000000 -0700
@@ -1,7 +1,7 @@
 from _compat_pickle import (IMPORT_MAPPING, REVERSE_IMPORT_MAPPING,
                             NAME_MAPPING, REVERSE_NAME_MAPPING)
 import builtins
-import pickle
+import pickle5 as pickle
 import io
 import collections
 import struct
@@ -11,19 +11,19 @@
 import unittest
 from test import support
 
-from test.pickletester import AbstractHookTests
-from test.pickletester import AbstractUnpickleTests
-from test.pickletester import AbstractPickleTests
-from test.pickletester import AbstractPickleModuleTests
-from test.pickletester import AbstractPersistentPicklerTests
-from test.pickletester import AbstractIdentityPersistentPicklerTests
-from test.pickletester import AbstractPicklerUnpicklerObjectTests
-from test.pickletester import AbstractDispatchTableTests
-from test.pickletester import AbstractCustomPicklerClass
-from test.pickletester import BigmemPickleTests
+from .pickletester import AbstractHookTests
+from .pickletester import AbstractUnpickleTests
+from .pickletester import AbstractPickleTests
+from .pickletester import AbstractPickleModuleTests
+from .pickletester import AbstractPersistentPicklerTests
+from .pickletester import AbstractIdentityPersistentPicklerTests
+from .pickletester import AbstractPicklerUnpicklerObjectTests
+from .pickletester import AbstractDispatchTableTests
+from .pickletester import AbstractCustomPicklerClass
+from .pickletester import BigmemPickleTests
 
 try:
-    import _pickle
+    from pickle5 import _pickle
     has_c_implementation = True
 except ImportError:
     has_c_implementation = False
@@ -212,7 +212,7 @@
 
 if has_c_implementation:
     class CPickleTests(AbstractPickleModuleTests):
-        from _pickle import dump, dumps, load, loads, Pickler, Unpickler
+        from pickle5._pickle import dump, dumps, load, loads, Pickler, Unpickler
 
     class CUnpicklerTests(PyUnpicklerTests):
         unpickler = _pickle.Unpickler
--- ../cpython-3.8.0rc1/Lib/test/test_picklebuffer.py	2019-10-01 05:58:26.000000000 -0700
+++ pickle5/test/test_picklebuffer.py	2019-10-10 22:31:20.000000000 -0700
@@ -4,7 +4,7 @@
 """
 
 import gc
-from pickle import PickleBuffer
+from pickle5 import PickleBuffer
 import weakref
 import unittest
 
